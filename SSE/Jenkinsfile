def label = "Devnetops-${UUID.randomUUID().toString()}"
def serviceaccount = "jenkins-admin"
podTemplate(label: label, serviceAccount: serviceaccount,
           containers: [containerTemplate(name: 'python3', image: 'python:3.8-alpine', ttyEnabled: true, command: 'cat'),
             containerTemplate(name: 'kubectl', image: 'nexgtech/kubectl:1.15', ttyEnabled: true, command: 'cat'),
                        containerTemplate(name: 'tox', image: 'devnetops.azurecr.io/devnetops-tox-updated', ttyEnabled: true, command: 'cat'),
               containerTemplate(name: 'docker', image: 'docker:18.09.9', ttyEnabled: true, command: 'cat')],
				volumes: [hostPathVolume(hostPath: '/var/run/docker.sock', mountPath: '/var/run/docker.sock')],
           		imagePullSecrets: ['devnetops'])

{
    node(label)
    {
		def Commit_Id
        def DockerReg_Url='devnetops.azurecr.io'
		def DockerReg_Credentials='ACR'
        def Docker_Image = 'devnetops-events'
        def Image_Tag = 't1'
        def K8s_Deployment = 'devnetops-events'
        def SONAR_HOST_URL='https://a9df39b070e0b4f318517a4fb48d14d3-1933974976.us-west-2.elb.amazonaws.com/sonar/'
		def SONAR_SCANNER='org.sonarsource.scanner.maven'
        def SONAR_PLUGIN='sonar-maven-plugin:3.2'
		try{
       stage('Git Checkout'){
            git branch: Git_Branch,
            url: Git_Url,
            credentialsId: Git_Credential

			this.Commit_Id = sh(returnStdout: true, script: 'git rev-parse --short=40 HEAD').trim()
			this.bitbucketStatusNotify('INPROGRESS')
        }
           stage ('Encrypting Source codes'){
            container('python3'){
              sh '''#!/bin/sh
              		apk add --no-cache --virtual .build-deps openssl-dev libffi-dev gcc musl-dev
                    pip3 install cython
                    pip3 install -r SSE/sse/requirements.txt
                    cd SSE && python3 setup.py build_ext --inplace
                    mkdir tmp
                    find . -name '*.so' -exec cp --parents \\{\\} tmp \\;
                    find . -name "requirements.txt" -exec cp --parents \\{\\} tmp \\;
                    find . -name "uwsgi.ini" -exec cp --parents \\{\\} tmp \\;
                    mkdir tmp/sse/logs
              '''}
         }

         stage('SonarQube Analysis') {
			withCredentials([usernamePassword(credentialsId: 'SONAR', passwordVariable: 'PASSWORD', usernameVariable: 'USERNAME')]){
			withSonarQubeEnv('SonarQube') {
			container('curl')
				{
					sh '''
					export SONAR_QG_NAME='sse_QG'
					echo "Creating SonarQube Gateway"
					curl -u ${USERNAME}:${PASSWORD} -X POST "${SONAR_HOST_URL}/api/qualitygates/create?name=$SONAR_QG_NAME"
					'''
					sh '''#!/bin/bash
					export SONAR_QG_NAME='sse_QG'
					curl -u ${USERNAME}:${PASSWORD} "${SONAR_HOST_URL}/api/qualitygates/show?name=$SONAR_QG_NAME" > qualitygate.json
					cat qualitygate.json
					curl_cmd=( curl -u ${USERNAME}:${PASSWORD} -X POST ${SONAR_HOST_URL}/api/qualitygates/ )
					url="create_condition"
					QG_ID=$( jq -r ".id" qualitygate.json )
					gateMetrics=(
					coverage,LT,80
					blocker_violations,GT,10
					critical_violations,GT,10
					major_violations,GT,0
					)
					query_fmt="gateId=%s&metric=%s&op=%s&error=%s"
					for metric in "${gateMetrics[@]}"; do
					IFS=, read -r m o e <<< "$metric"
					printf -v query "$query_fmt" "$QG_ID" "$m" "$o" "$e"
					"${curl_cmd[@]}""${url}?${query}"
					done
					'''
					sh '''
					export SONAR_PROJECT_NAME='devnetops-sse'
					export SONAR_PROJECT_KEY='devnetops-sse'
					export SONAR_QG_NAME='sse_QG'
					curl -u ${USERNAME}:${PASSWORD} -X POST "${SONAR_HOST_URL}/api/projects/create?project=$SONAR_PROJECT_KEY&name=$SONAR_PROJECT_NAME"
					curl -u ${USERNAME}:${PASSWORD} "${SONAR_HOST_URL}/api/qualitygates/show?name=$SONAR_QG_NAME" > qualitygate.json
					QG_ID=$( jq -r ".id" qualitygate.json )
					curl -u ${USERNAME}:${PASSWORD} -X POST "${SONAR_HOST_URL}/api/qualitygates/select?gateId=$QG_ID&projectKey=$SONAR_PROJECT_KEY"
					cat qualitygate.json | jq -r ".conditions[].id" > cgid.txt
					cid=$(head -n 1 cgid.txt)
					echo "Updating Sonar Qube gateway"
					curl -u ${USERNAME}:${PASSWORD} -X POST "${SONAR_HOST_URL}/api/qualitygates/update_condition?gateId=$QG_ID&id=$cid&metric=coverage&op=LT&error=$coverage"
					bvid=$(sed -n '2p' cgid.txt)
					curl -u ${USERNAME}:${PASSWORD} -X POST "${SONAR_HOST_URL}/api/qualitygates/update_condition?gateId=$QG_ID&id=$bvid&metric=blocker_violations&op=GT&error=$blocker"
					cvid=$(sed -n '3p' cgid.txt)
					curl -u ${USERNAME}:${PASSWORD} -X POST "${SONAR_HOST_URL}/api/qualitygates/update_condition?gateId=$QG_ID&id=$cvid&metric=critical_violations&op=GT&error=$critical"
					mvid=$(sed -n '4p' cgid.txt)
					curl -u ${USERNAME}:${PASSWORD} -k -X POST "${SONAR_HOST_URL}/api/qualitygates/update_condition?gateId=$QG_ID&id=$mvid&metric=major_violations&op=GT&error=$major"
					echo "Displaying Existing Sonar Issues"
					curl -k -u ${USERNAME}:${PASSWORD} "${SONAR_HOST_URL}/api/measures/component?metricKeys=critical_violations,coverage,blocker_violations,major_violations&component=$SONAR_PROJECT_NAME" > sonar-result.json
					cat sonar-result.json
					'''
					}
					container('maven')
					{
					sh 'apk update'
					sh 'apk add nodejs'
					withSonarQubeEnv('SonarQube')
					{
					println('Sonar Method enter');
					
					def scannerHome = tool 'Sonar Scanner';
					sh "${scannerHome}/bin/sonar-scanner -Dsonar.login=$USERNAME -Dsonar.password=$PASSWORD -Dsonar.projectKey=devnetops-sse -Dsonar.projectName=devnetops-sse -Dsonar.language=py -Dsonar.sources=SSE/sse ";
					println('Sonar Method exit');
					echo "Access the SonarQube URL from the Platform Dashboard tile"
					}
					sleep 40
					timeout(time: 10, unit: 'MINUTES')
					{
					def qg = waitForQualityGate()
					if (qg.status != 'OK')
					{
					error "Pipeline aborted due to quality gate failure: ${qg.status}"
					}
					}
					}
					} 
					}
		}
	 stage (' Create Docker image'){
			container('docker'){
              sh 'pwd'
              sh 'ls'
              sh ("docker build -t ${DockerReg_Url}/${Docker_Image}:${Image_Tag} --network=host -f SSE/Dockerfile_Dev .")
			}

		}
		stage('Pushing the Docker image to Container Registry') {
              container('docker') {
	             withCredentials([usernamePassword(credentialsId: 'ACR', passwordVariable: 'PASSWORD', usernameVariable: 'USERNAME')])
				 {
			     sh ("docker login -u ${USERNAME} -p ${PASSWORD} "+DockerReg_Url)
				 sh ("docker push ${DockerReg_Url}/${Docker_Image}:${Image_Tag}")
         }
             }
         }

		stage('Deploying to Kubernetes') {
				container('kubectl') {
				try{
					sh("kubectl get deployment ${K8s_Deployment}")
					if(true){
						//sh ("kubectl set image deployment/${K8s_Deployment} ${K8s_Deployment}=${DockerReg_Url}/${Docker_Image}:${Image_Tag}")
                      	//sh ("kubectl get pods | grep 'onboardmgmt-' | grep -v grep | awk '{print $1}' | xargs kubectl delete po")
                      	sh("kubectl delete deployment ${K8s_Deployment}")
                      	sh("kubectl apply -f SSE/sse.yml")
					}
				}
				catch(e){
                  	sh("kubectl apply -f SSE/sse.yml")
					echo "deploying"
              }
			}
		}

		currentBuild.result = 'SUCCESS'
        echo "RESULT: ${currentBuild.result}"
        echo "Finished: ${currentBuild.result}"
		}
		 catch (Exception err) {
        currentBuild.result = 'FAILURE'
        echo "RESULT: ${currentBuild.result}"
        echo "Finished: ${currentBuild.result}"
               }
		finally {
            this.bitbucketStatusNotify(currentBuild.result)
        }

	}
}
def bitbucketStatusNotify(String state) {

    if('SUCCESS' == state || 'FAILED' == state) {
    // Set result of currentBuild !Important!
        currentBuild.result = state
    }

   // notifyBitbucket commitSha1: this.Commit_Id, considerUnstableAsSuccess: true, credentialsId: Git_Credential, disableInprogressNotification: false, ignoreUnverifiedSSLPeer: true, includeBuildNumberInKey: false, prependParentProjectKey: false, projectKey: '', stashServerBaseUrl: 'https://innersource.accenture.com/'
}
